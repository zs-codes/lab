## What are Deployments?

**Deployments** are a way to declare the desired state for Pods and ReplicaSets in Kubernetes.

### Key Concepts

- **Desired State**: You declare what you want (e.g., "I want 3 nginx pods running")
- **Kubernetes ensures**: The actual state matches desired state
- **Self-healing**: If a pod dies, deployment automatically creates a new one
- **Managed updates**: Roll out new versions without downtime
- **Rollback capability**: Easily revert to previous versions

### Deployment vs Pod

| Pod | Deployment |
|-----|------------|
| Single instance | Manages multiple pod replicas |
| No auto-restart on node failure | Auto-recreates pods on failure |
| Manual scaling | Declarative scaling |
| No update strategy | Rolling updates built-in |
| Ephemeral | Persistent desired state |

### What Deployments Do

1. **Create and manage ReplicaSets** - Which in turn manage Pods
2. **Scale applications** - Increase/decrease replicas
3. **Rolling updates** - Update pods without downtime
4. **Rollback** - Revert to previous versions
5. **Self-healing** - Replace failed pods automatically
6. **Declarative updates** - Change desired state, Kubernetes does the work

---

## Creating Deployments

### Imperative Creation

```bash
# Create deployment with 3 replicas
k create deployment my-dep --image=nginx --replicas=3

# Create deployment and expose port
k create deployment my-dep --image=busybox --port=5701

# Create deployment with specific image version
k create deployment web --image=nginx:1.19 --replicas=5

# Shorter alias
k create deploy test --image=httpd --replicas=3
```

**Example:**
```bash
zhivko.simeonov@CKG2YK23F1 ~ % k create deploy test --image=httpd --replicas=3
deployment.apps/test created
```

### What Gets Created?

When you create a deployment, Kubernetes creates:
1. **Deployment** - The controller
2. **ReplicaSet** - Managed by deployment
3. **Pods** - Managed by ReplicaSet

```bash
# View all created resources
k get all

# Output:
# NAME                        READY   STATUS    RESTARTS   AGE
# pod/test-6546ccdcf9-kfqz7   1/1     Running   0          3s
# pod/test-6546ccdcf9-vqz67   1/1     Running   0          3s
# pod/test-6546ccdcf9-zjqng   1/1     Running   0          3s
#
# NAME                   READY   UP-TO-DATE   AVAILABLE   AGE
# deployment.apps/test   3/3     3            3           3s
#
# NAME                              DESIRED   CURRENT   READY   AGE
# replicaset.apps/test-6546ccdcf9   3         3         3       3s
```

### Pod Naming Convention

```
deployment-name-replicaset-hash-pod-hash
    ↓           ↓              ↓
  test    -  6546ccdcf9  -   kfqz7
```

- **test** - Deployment name
- **6546ccdcf9** - ReplicaSet hash (changes with each deployment revision)
- **kfqz7** - Random pod identifier

---

## Managing Deployments

### Viewing Deployments

```bash
# List deployments
k get deployments
k get deploy
k get deployments.apps

# Example output:
# NAME   READY   UP-TO-DATE   AVAILABLE   AGE
# test   3/3     3            3           47s
```

**Column meanings:**
- **READY** - Ready replicas / Desired replicas
- **UP-TO-DATE** - Replicas updated to latest specification
- **AVAILABLE** - Replicas available for users
- **AGE** - Time since deployment created

```bash
# Wide output
k get deploy -o wide

# All namespaces
k get deploy -A

# Watch deployments
k get deploy -w

# Show labels
k get deploy --show-labels
```

### Describing Deployments

```bash
# Detailed deployment information
k describe deployments.apps test
k describe deploy test

# Shows:
# - Deployment strategy
# - Replicas (desired, updated, available)
# - Pod template
# - Conditions
# - Events
# - ReplicaSet information
```

### Editing Deployments

```bash
# Edit deployment interactively
k edit deployments.apps test
k edit deploy test

# Opens in default editor (vim)
# Changes applied immediately on save
```

**Common edits:**
- Change replica count
- Update container image
- Add environment variables
- Change resource limits
- Modify deployment strategy

### Deleting Deployments

```bash
# Delete deployment (also deletes ReplicaSet and Pods)
k delete deployments.apps test
k delete deploy test

# Output: deployment.apps "test" deleted from default namespace

# Delete from YAML file
k delete -f deploy.yaml

# Delete multiple deployments
k delete deploy test1 test2 test3

# Delete all deployments in namespace
k delete deploy --all
```

⚠️ **Important**: Deleting a deployment also deletes:
- The ReplicaSet it manages
- All Pods managed by that ReplicaSet

---

## Generating Deployment YAML

### Dry Run Method

```bash
# Generate deployment YAML
k create deploy zhivko --image=httpd --replicas=10 --dry-run=client -o yaml > deploy.yaml

# View generated file
cat deploy.yaml
```

**Generated YAML:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: zhivko
  name: zhivko
spec:
  replicas: 10
  selector:
    matchLabels:
      app: zhivko
  strategy: {}
  template:
    metadata:
      labels:
        app: zhivko
    spec:
      containers:
      - image: httpd
        name: httpd
        resources: {}
status: {}
```

### Cleaning Up Generated YAML

**Remove unnecessary fields:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: zhivko
  name: zhivko
spec:
  replicas: 10
  selector:
    matchLabels:
      app: zhivko
  template:
    metadata:
      labels:
        app: zhivko
    spec:
      containers:
      - image: httpd
        name: httpd
```

**Removed:**
- `strategy: {}` - Empty, will use default
- `resources: {}` - Empty
- `status: {}` - Managed by Kubernetes

---

## Understanding ReplicaSets

### What are ReplicaSets?

**ReplicaSets** ensure a specified number of pod replicas are running at any time.

```bash
# View ReplicaSets
k get replicasets
k get rs
k get replicasets.apps

# Example output:
# NAME               DESIRED   CURRENT   READY   AGE
# zhivko-8c87b45c8   5         5         5       2m5s
```

**Column meanings:**
- **DESIRED** - Number of replicas defined in spec
- **CURRENT** - Number of replicas currently running
- **READY** - Number of replicas ready to serve traffic

### ReplicaSet Naming

```
deployment-name-pod-template-hash
      ↓              ↓
   zhivko      -  8c87b45c8
```

- **zhivko** - Deployment name
- **8c87b45c8** - Hash of pod template (changes when template changes)

### Describing ReplicaSets

```bash
k describe replicasets.apps zhivko-8c87b45c8
k describe rs zhivko-8c87b45c8
```

### ⚠️ Important: Don't Manage ReplicaSets Directly

**According to Kubernetes documentation:**
- ReplicaSets **should NOT be managed by users**
- They are **managed by Deployments**
- Always manage Deployments, not ReplicaSets directly

**Why?**
- Deployments provide rollback capability
- Deployments manage multiple ReplicaSets (for updates)
- Deployments provide update strategies
- Direct ReplicaSet management loses these benefits

---

## Deployment Strategies

### Two Main Strategies

1. **RollingUpdate** (default) - Gradual replacement
2. **Recreate** - Delete all, then create new

### Strategy Configuration

Located in `.spec.strategy`:

```yaml
spec:
  strategy:
    type: RollingUpdate  # or Recreate
```

---

## Rolling Update Strategy (Default)

### What is Rolling Update?

Gradually replaces old pods with new ones:
1. Create a few new pods
2. Wait for them to be ready
3. Terminate a few old pods
4. Repeat until all pods are updated

**Benefits:**
- ✅ Zero downtime
- ✅ Gradual rollout
- ✅ Can pause and resume
- ✅ Easy rollback
- ✅ Application always available

### Rolling Update Parameters

```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
```

#### maxUnavailable

**Maximum number of pods that can be unavailable during update**

```yaml
maxUnavailable: 1  # Can be number or percentage
```

**Examples:**
- `maxUnavailable: 1` - At most 1 pod unavailable
- `maxUnavailable: 25%` - At most 25% of pods unavailable
- `maxUnavailable: 0` - All pods must be available (use with maxSurge)

**Use case:**
- If your app needs 8 replicas to handle traffic
- Set `maxUnavailable: 2`
- Ensures at least 6 replicas always running during update

#### maxSurge

**Maximum number of pods that can be created above desired replicas**

```yaml
maxSurge: 1  # Can be number or percentage
```

**Examples:**
- `maxSurge: 1` - Can create 1 extra pod during update
- `maxSurge: 50%` - Can create 50% extra pods during update
- `maxSurge: 0` - No extra pods (use with maxUnavailable)

**Use case:**
- If you have 10 replicas
- `maxSurge: 2` means during update you might have up to 12 pods temporarily
- Faster updates but uses more resources temporarily

### Rolling Update Examples

#### Example 1: Conservative Update

```yaml
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  # Only 1 pod down at a time
      maxSurge: 1        # Only 1 extra pod at a time
```

**Update flow:**
- Start: 10 pods running
- Create 1 new pod (11 total)
- Wait for new pod to be ready
- Terminate 1 old pod (10 total)
- Repeat until all updated

**Characteristics:**
- Slowest update
- Minimal resource overhead
- Maximum availability

#### Example 2: Fast Update

```yaml
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 3
      maxSurge: 3
```

**Update flow:**
- Start: 10 pods running
- Create 3 new pods (13 total)
- Terminate 3 old pods (10 total)
- Repeat until all updated

**Characteristics:**
- Faster update
- More resource usage (up to 13 pods)
- Lower availability during update (down to 7 pods)

#### Example 3: Maximum Availability

```yaml
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0  # Never go below 10 pods
      maxSurge: 5        # Can have up to 15 pods temporarily
```

**Characteristics:**
- Always 10+ pods available
- Requires extra resources
- Zero downtime guarantee

### Updating a Deployment

```bash
# Change replicas from 10 to 5
vim deploy.yaml
# Change: replicas: 10 → replicas: 5

k apply -f deploy.yaml

# Kubernetes gradually scales down:
# 10 → 9 → 8 → 7 → 6 → 5
```

### Changing Container Image

**Original:**
```yaml
spec:
  containers:
  - image: httpd
    name: httpd
```

**Updated:**
```yaml
spec:
  containers:
  - image: httpd:alpine3.18
    name: httpd
```

```bash
k apply -f deploy.yaml
```

**What happens:**
1. Kubernetes detects image change
2. Creates new ReplicaSet with new image
3. Gradually scales up new ReplicaSet
4. Gradually scales down old ReplicaSet
5. Old ReplicaSet kept (scaled to 0) for rollback

**By default, updates happen in batches:**
- With 10 replicas and default settings
- Updates in batches (not all at once)
- Ensures application remains available

### Verify Rolling Update

```bash
# Watch update in real-time
k get pods -w

# Check rollout status
k rollout status deployment/zhivko

# View rollout history
k rollout history deployment/zhivko

# Example output:
# deployment.apps/zhivko 
# REVISION  CHANGE-CAUSE
# 1         <none>
# 2         <none>
```

---

## Recreate Strategy

### What is Recreate?

Terminates all old pods before creating new ones:
1. Delete all existing pods
2. Wait for termination
3. Create all new pods

```yaml
spec:
  strategy:
    type: Recreate
```

**Characteristics:**
- ❌ Downtime during update
- ✅ Simple and predictable
- ✅ No mixed versions running
- ✅ Lower resource usage (no extra pods)

**Use cases:**
- Development environments
- Applications that can't run multiple versions simultaneously
- Database migrations requiring downtime
- When resource constraints prevent extra pods

### Example: Recreate Strategy

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zhivko
spec:
  replicas: 5
  strategy:
    type: Recreate  # Changed from RollingUpdate
  selector:
    matchLabels:
      app: zhivko
  template:
    metadata:
      labels:
        app: zhivko
    spec:
      containers:
      - image: httpd:alpine3.18
        name: httpd
```

```bash
k apply -f deploy.yaml

# Watch pods
k get pods -w

# Output shows:
# All old pods terminated first
# Then all new pods created
# Brief period with 0 pods (downtime!)
```

**⚠️ Not recommended for production** unless you specifically need it.

---

## Simulating Failures

### Breaking a Deployment

**Adding a failing command:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zhivko
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: zhivko
  template:
    metadata:
      labels:
        app: zhivko
    spec:
      containers:
      - image: httpd
        name: httpd
        command: ["/bin/bash", "-c"]  # Override default command
        args: ["sleep 5; exit 1"]      # Sleep then fail
```

**What this does:**
- Overrides default container command
- Sleeps for 5 seconds
- Exits with error code 1
- Container fails and restarts

```bash
k apply -f deploy.yaml

# Watch pods
watch kubectl get pods
# or
k get pods -w
```

### Observed Behavior

```bash
Every 1.0s: kubectl get pods

NAME                      READY   STATUS              RESTARTS      AGE
httpd                     1/1     Running             0             118m
nginx-docs                1/1     Running             0             47h
nginx-yaml                1/1     Running             0             47h
zhivko-67877fbbd6-ffkkf   1/1     Running             0             7m54s
zhivko-67877fbbd6-grhwx   1/1     Running             0             7m52s
zhivko-67877fbbd6-lglqt   1/1     Running             0             7m57s
zhivko-67877fbbd6-nbdgk   1/1     Running             0             7m52s
zhivko-67877fbbd6-pn2cl   1/1     Running             0             7m50s
zhivko-67877fbbd6-rwj9j   1/1     Running             0             7m57s
zhivko-67877fbbd6-wv7wg   1/1     Running             0             7m59s
zhivko-67877fbbd6-xpcpt   1/1     Running             0             7m50s
zhivko-67877fbbd6-ztbw6   1/1     Running             0             7m54s
zhivko-f9f649666-grz9w    0/1     RunContainerError   1 (19s ago)   23s
zhivko-f9f649666-k2sg7    0/1     RunContainerError   1 (19s ago)   23s
```

### What's Happening?

**Two ReplicaSets visible:**
1. **Old ReplicaSet** (`zhivko-67877fbbd6`) - 9 pods running (old working version)
2. **New ReplicaSet** (`zhivko-f9f649666`) - 2 pods failing (new broken version)

**Status progression for new pods:**
```
Pending → Running → Error → CrashLoopBackOff
```

**Why only 2 new pods?**
- `maxSurge: 1` allows 1 extra pod
- `maxUnavailable: 1` allows 1 pod to be down
- Kubernetes tries to create 2 new pods
- Both fail repeatedly
- **Old pods stay running** - Application still available!

### CrashLoopBackOff Explained

```bash
NAME                      READY   STATUS             RESTARTS
zhivko-f9f649666-grz9w    0/1     CrashLoopBackOff   5 (2m ago)
```

**CrashLoopBackOff** means:
- Container keeps crashing
- Kubernetes keeps trying to restart it
- **Exponential backoff** between restart attempts:
  - 0s, 10s, 20s, 40s, 80s, 160s, 300s (max 5 minutes)
- After multiple failures, waits longer between attempts

**Restart count increases:**
```
RESTARTS: 0 → 1 → 2 → 3 → 4 → 5...
```

### Why Application Still Works

**Because of `maxUnavailable: 1`:**
- Only 1 old pod terminated at a time
- New pod must be Ready before old pod deleted
- Since new pods never become Ready, old pods never deleted
- **Application remains available with 9/10 replicas**

**This is deployment self-healing in action!**

### Checking Deployment Status

```bash
# Rollout status
k rollout status deployment/zhivko
# Output: Waiting for deployment "zhivko" rollout to finish: 2 out of 10 new replicas have been updated...

# Deployment conditions
k get deploy zhivko -o yaml | grep -A 10 conditions

# Describe deployment
k describe deploy zhivko
# Shows: Pods failed to start, check events

# Check events
k get events --sort-by='.lastTimestamp'
```

### Fixing the Broken Deployment

**Method 1: Edit the YAML file**
```bash
# Remove the broken command
vim deploy.yaml
# Delete these lines:
#   command: ["/bin/bash", "-c"]
#   args: ["sleep 5; exit 1"]

# Apply fixed version
k apply -f deploy.yaml

# Pods immediately start working
```

**Method 2: Rollback to previous version**
```bash
# Undo the last rollout
k rollout undo deployment/zhivko

# Old working version restored
# New broken pods deleted
```

**Method 3: Rollback to specific revision**
```bash
# View rollout history
k rollout history deployment/zhivko

# Rollback to specific revision
k rollout undo deployment/zhivko --to-revision=1
```

---

## Deployment Rollout Commands

### Check Rollout Status

```bash
# View rollout status
k rollout status deployment/zhivko

# Example output:
# Waiting for deployment "zhivko" rollout to finish: 5 of 10 updated replicas are available...
# deployment "zhivko" successfully rolled out
```

### View Rollout History

```bash
# View all revisions
k rollout history deployment/zhivko

# Output:
# deployment.apps/zhivko 
# REVISION  CHANGE-CAUSE
# 1         <none>
# 2         <none>
# 3         <none>

# View specific revision details
k rollout history deployment/zhivko --revision=2
```

### Pause and Resume Rollouts

```bash
# Pause rollout (useful for canary deployments)
k rollout pause deployment/zhivko

# Make multiple changes
k set image deployment/zhivko httpd=httpd:2.4
k set env deployment/zhivko ENV=production

# Resume rollout (apply all changes at once)
k rollout resume deployment/zhivko
```

### Restart Deployment

```bash
# Restart all pods (useful for picking up ConfigMap changes)
k rollout restart deployment/zhivko

# Creates new ReplicaSet
# Gradually replaces all pods
```

### Rollback Deployment

```bash
# Undo last rollout
k rollout undo deployment/zhivko

# Rollback to specific revision
k rollout undo deployment/zhivko --to-revision=2

# Check rollback status
k rollout status deployment/zhivko
```

---

## Useful Deployment Tips

### Tip 1: Pipe kubectl create help to vim

```bash
# Open help in vim for easy navigation
k create deploy -h | vim -

# In vim:
# - Search: /dry-run
# - Navigate: n (next), N (previous)
# - Quit: :q
```

### Tip 2: Quick Scaling

```bash
# Scale deployment imperatively
k scale deployment zhivko --replicas=20

# Check scaling
k get deploy zhivko

# Output:
# NAME     READY   UP-TO-DATE   AVAILABLE   AGE
# zhivko   20/20   20           20          10m
```

### Tip 3: Update Image Imperatively

```bash
# Update container image
k set image deployment/zhivko httpd=httpd:alpine3.19

# Record change in history
k set image deployment/zhivko httpd=httpd:alpine3.19 --record

# View recorded change
k rollout history deployment/zhivko
# Now shows: CHANGE-CAUSE: kubectl set image ...
```

### Tip 4: Check Which Pods Belong to Deployment

```bash
# Get pods with label selector
k get pods -l app=zhivko

# Only shows pods from this deployment
```

### Tip 5: Export and Clean Deployment YAML

```bash
# Get current deployment YAML
k get deploy zhivko -o yaml > zhivko-export.yaml

# Clean up (remove managed fields, status, etc.)
k get deploy zhivko -o yaml \
  | grep -v "creationTimestamp\|resourceVersion\|uid\|generation" \
  > zhivko-clean.yaml
```

---

## Complete Deployment YAML Example

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
    environment: production
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        version: v1.21
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
          name: http
        env:
        - name: ENVIRONMENT
          value: "production"
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

---

## Key Takeaways

1. **Deployments manage desired state** - You declare, Kubernetes ensures
2. **Deployments create ReplicaSets** - Which create Pods
3. **Don't manage ReplicaSets directly** - Always use Deployments
4. **RollingUpdate is default** - Zero downtime updates
5. **Recreate causes downtime** - Use only when necessary
6. **maxUnavailable** - Maximum pods that can be down during update
7. **maxSurge** - Maximum extra pods during update
8. **Self-healing** - Failed updates don't break running application
9. **Rollback capability** - Easy to revert bad updates
10. **`--dry-run=client -o yaml`** - Quick way to generate templates

---

## Quick Reference

| Task | Command |
|------|---------|
| Create deployment | `k create deploy <name> --image=<image> --replicas=<n>` |
| List deployments | `k get deploy` |
| Describe deployment | `k describe deploy <name>` |
| Edit deployment | `k edit deploy <name>` |
| Delete deployment | `k delete deploy <name>` |
| Scale deployment | `k scale deploy <name> --replicas=<n>` |
| Update image | `k set image deploy/<name> <container>=<image>` |
| Rollout status | `k rollout status deploy/<name>` |
| Rollout history | `k rollout history deploy/<name>` |
| Rollback | `k rollout undo deploy/<name>` |
| Restart deployment | `k rollout restart deploy/<name>` |
| Generate YAML | `k create deploy <name> --image=<image> --dry-run=client -o yaml > deploy.yaml` |
| Apply YAML | `k apply -f deploy.yaml` |