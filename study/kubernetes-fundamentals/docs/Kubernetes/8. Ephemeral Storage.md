## üìÅ What is Ephemeral Storage?

**Ephemeral storage** is temporary storage that exists only for the lifetime of a pod. When the pod is deleted, the storage and all its data are permanently lost.

### Key Characteristics
- **Temporary** - Data is lost when pod terminates
- **Pod-scoped** - Tied to pod lifecycle
- **Node-local** - Stored on the worker node
- **Shareable** - Can be shared between containers in the same pod
- **No persistence** - Not suitable for data that needs to survive pod restarts

---

## üìÇ Types of Ephemeral Storage

### 1. emptyDir Volume

The most common ephemeral storage type - creates an empty directory when pod starts.

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
  name: nginx-storage
spec:
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
    - mountPath: /scratch
      name: scratch-volume
  - image: busybox
    name: busybox
    command: ["/bin/sh", "-c"]
    args: ["sleep 1000"]
    volumeMounts:
    - mountPath: /scratch
      name: scratch-volume
  volumes:
  - name: scratch-volume
    emptyDir:
      sizeLimit: 500Mi
```

### emptyDir Configuration Options

```yaml
volumes:
- name: cache-volume
  emptyDir:
    sizeLimit: 1Gi           # Limit storage size
    medium: Memory           # Store in RAM (tmpfs)
```

**Medium Options:**
- **Default** (empty) - Uses node's default storage
- **Memory** - Uses tmpfs (RAM-based filesystem)

### 2. Projected Volumes
Combine multiple volume sources into single directory:
```yaml
volumes:
- name: projected-volume
  projected:
    sources:
    - secret:
        name: my-secret
    - configMap:
        name: my-config
```

### 3. Container Filesystem
Each container gets ephemeral storage for:
- Container image layers
- Writable container layer
- Logs written to stdout/stderr

---

## üéØ Production Use Cases for Ephemeral Storage

### 1. **Temporary Data Processing**
```yaml
# Data processing pipeline
- name: data-processor
  emptyDir:
    sizeLimit: 10Gi
```
- **Use case**: ETL jobs, data transformations
- **Benefit**: Fast local storage for intermediate files
- **Example**: Processing CSV files before loading to database

### 2. **Application Caches**
```yaml
- name: app-cache
  emptyDir:
    medium: Memory  # RAM-based for speed
    sizeLimit: 2Gi
```
- **Use case**: Application-level caching (Redis, Memcached)
- **Benefit**: Ultra-fast access, automatically cleaned up
- **Example**: Web application session cache

### 3. **Shared Scratch Space**
```yaml
# Multiple containers sharing workspace
volumeMounts:
- mountPath: /shared-data
  name: scratch-volume
```
- **Use case**: Multi-container data processing
- **Benefit**: Inter-container communication without network
- **Example**: Log processor + file analyzer containers

### 4. **Init Container Data Sharing**
```yaml
initContainers:
- name: data-downloader
  volumeMounts:
  - mountPath: /downloaded-data
    name: init-data
containers:
- name: app
  volumeMounts:
  - mountPath: /app-data
    name: init-data
```
- **Use case**: App initialization, config preparation
- **Benefit**: Clean separation of setup vs runtime
- **Example**: Download configuration files before app starts

### 5. **Sidecar Pattern Implementation**
```yaml
# Log shipper sidecar
containers:
- name: app
  volumeMounts:
  - mountPath: /var/log/app
    name: log-volume
- name: log-shipper
  volumeMounts:
  - mountPath: /logs
    name: log-volume
```
- **Use case**: Log collection, monitoring, proxies
- **Benefit**: Separation of concerns
- **Example**: Fluentd sidecar collecting application logs

### 6. **Build and CI/CD Workloads**
```yaml
- name: build-workspace
  emptyDir:
    sizeLimit: 20Gi
```
- **Use case**: Docker builds, compilation, testing
- **Benefit**: Clean workspace for each build
- **Example**: Jenkins agents, GitLab runners

---

## üîÑ Accessing Containers in Multi-Container Pods

### Exec into Specific Container
```bash
# Access specific container in pod
kubectl exec -it <pod-name> -c <container-name> -- /bin/bash

# Example from your notes
kubectl exec -it nginx-storage -c nginx -- /bin/bash
kubectl exec -it nginx-storage -c busybox -- /bin/sh
```

### Testing Shared Storage
```bash
# In nginx container
echo "Hello from nginx" > /scratch/nginx-file.txt

# In busybox container  
cat /scratch/nginx-file.txt  # Should show "Hello from nginx"
```

---

## ‚öñÔ∏è Ephemeral vs Persistent Storage

### When to Use Ephemeral Storage ‚úÖ
- **Temporary data processing**
- **Application caches**
- **Build artifacts**
- **Log buffers**
- **Init container setup**
- **Inter-container communication**
- **Testing and development**

### When to Use Persistent Storage ‚ùå
- **Database data**
- **User uploads**
- **Configuration that survives restarts**
- **Backup data**
- **Any critical business data**

---

## üöÄ Advanced Ephemeral Storage Patterns

### 1. Memory-Based Cache
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: redis-cache
spec:
  containers:
  - name: redis
    image: redis:alpine
    volumeMounts:
    - mountPath: /data
      name: redis-data
  volumes:
  - name: redis-data
    emptyDir:
      medium: Memory
      sizeLimit: 4Gi
```

### 2. Multi-Stage Processing
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: data-pipeline
spec:
  initContainers:
  - name: data-fetcher
    image: curlimages/curl
    command: ['sh', '-c', 'curl -o /data/input.json https://api.example.com/data']
    volumeMounts:
    - mountPath: /data
      name: pipeline-data
  containers:
  - name: data-processor
    image: python:3.9
    command: ['python', '/app/process.py']
    volumeMounts:
    - mountPath: /data
      name: pipeline-data
  - name: data-uploader
    image: awscli/aws-cli
    command: ['aws', 's3', 'cp', '/data/output.json', 's3://bucket/']
    volumeMounts:
    - mountPath: /data
      name: pipeline-data
  volumes:
  - name: pipeline-data
    emptyDir:
      sizeLimit: 5Gi
```

### 3. Log Aggregation Pattern
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-with-logging
spec:
  containers:
  - name: application
    image: myapp:latest
    volumeMounts:
    - mountPath: /var/log/app
      name: log-volume
  - name: log-shipper
    image: fluent/fluent-bit
    volumeMounts:
    - mountPath: /fluent-bit/log
      name: log-volume
  volumes:
  - name: log-volume
    emptyDir:
      sizeLimit: 1Gi
```

---

## üìä Storage Resource Management

### Setting Size Limits
```yaml
volumes:
- name: limited-storage
  emptyDir:
    sizeLimit: 2Gi  # Prevents pod from using too much storage
```

### Monitoring Ephemeral Storage
```bash
# Check ephemeral storage usage
kubectl top pods
kubectl describe node <node-name>

# Pod resource requests/limits
resources:
  requests:
    ephemeral-storage: 1Gi
  limits:
    ephemeral-storage: 2Gi
```

---

## üéØ Best Practices

### Resource Management
- **Always set sizeLimit** - Prevent storage exhaustion
- **Monitor usage** - Track ephemeral storage consumption
- **Set resource requests/limits** - Ensure proper scheduling

### Security
- **Sensitive data** - Don't store secrets in ephemeral storage long-term
- **Cleanup** - Ensure temporary files are properly cleaned
- **Access control** - Use proper file permissions

### Performance
- **Use Memory medium** - For high-performance caches
- **Local storage** - Better performance than network storage
- **Size appropriately** - Balance performance vs resource usage

### Design Patterns
- **Init containers** - Use for setup and initialization
- **Sidecar pattern** - Separate concerns with shared storage
- **Graceful degradation** - Handle storage unavailability

---

## üìã Quick Commands Reference

```bash
# Pod management
kubectl exec -it <pod> -c <container> -- /bin/bash
kubectl logs <pod> -c <container>
kubectl describe pod <pod>

# Storage debugging
kubectl get pv                    # Persistent volumes
kubectl get pvc                   # Persistent volume claims
kubectl describe pod <pod>        # Check volume mounts
kubectl top pods                  # Resource usage

# Testing shared storage
kubectl exec <pod> -c <container1> -- touch /shared/test
kubectl exec <pod> -c <container2> -- ls /shared/
```
