# Kubernetes Networking

## üåê Pod Networking Fundamentals

### Core Networking Principles
- **Networking happens at the Pod level**
- **Each Pod gets its own IP address** (unique within the cluster)
- **By default, pods can connect to all pods on all nodes** (flat networking model)
- **Containers within pods communicate via localhost** (they share the same network namespace)

### Pod Networking Characteristics
- Pods are ephemeral - IP addresses change when pods restart/reschedule
- Pods can be moved across nodes dynamically
- Direct pod-to-pod communication is possible but not recommended for applications

---

## üîå CNI (Container Network Interface) Plugins

### What CNI Does
- Provides network connectivity to containers
- Configures network interfaces in containers  
- Assigns IP addresses and sets up routes
- Manages IPTables rules on nodes

### Popular CNI Plugins
- **Cilium** - eBPF-based, advanced security and observability
- **Calico** - Network policies, BGP routing
- **Flannel** - Simple overlay networking
- **Weave** - Encrypted networking mesh

### Azure AKS CNI Options
When creating AKS clusters, choose from:
- **Azure CNI** - Integrates with Azure virtual networks
- **Kubenet** - Basic plugin with NAT
- **Bring your own CNI** - Custom CNI plugin

### Checking CNI Configuration
```bash
# Access Rancher Desktop VM
rdctl shell bash

# Check CNI configuration
tree /etc/cni
cat /etc/cni/net.d/10-flannel.conflist
```

**Example Flannel Configuration:**
```json
{
  "name":"cbr0",
  "cniVersion":"0.3.1",
  "plugins":[
    {
      "type":"flannel",
      "delegate":{
        "hairpinMode":true,
        "forceAddress":true,
        "isDefaultGateway":true
      }
    },
    {
      "type":"portmap",
      "capabilities":{
        "portMappings":true
      }
    }
  ]
}
```

---

## üéØ Services - Making Pods Available

### Why Do We Need Services?
- **Pods are ephemeral** - shouldn't expect long lifespan
- **Pods constantly change** - moved across nodes, restarted
- **IP addresses change** - system needs to track dynamic IPs
- **Load balancing** - distribute traffic across multiple pods

### What is a Service?
A **Service is a grouping of pods** that provides:
- Stable endpoint (Service IP doesn't change)
- Load balancing (automatically distributes traffic)
- Service discovery (pods can find services by name)
- Health checking (only routes to healthy pods)

### Service Types

#### 1. ClusterIP (Default)
- Creates cluster-wide IP for internal access
- Only accessible from within the cluster
- Most common for internal services

#### 2. NodePort
- Exposes a port on each node
- Allows direct access through any node's IP
- **Generally avoid in production** - security concerns

#### 3. LoadBalancer
- Used with cloud providers
- Creates external load balancer (Azure LB, AWS ELB, etc.)
- Routes external traffic into the cluster
- Also works with k3s/Rancher Desktop

---

## üöÄ Creating and Managing Services

### Method 1: Quick Expose (Not Production-Ready)
```bash
# Expose a deployment
kubectl expose deployment frontend --port 8080

# Check services
kubectl get service -o wide
```

**Output Example:**
```
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    SELECTOR
frontend     ClusterIP   10.43.96.21   <none>        8080/TCP   app=frontend
```

### Method 2: Edit Service Type
```bash
# Edit service to change type
kubectl edit svc frontend

# Check updated service
kubectl get svc
```

**LoadBalancer Output:**
```
NAME         TYPE           CLUSTER-IP    EXTERNAL-IP    PORT(S)
frontend     LoadBalancer   10.43.96.21   192.168.64.2   8080:30353/TCP
```

### Method 3: YAML Files (Production Approach)
```bash
# Export current service to YAML
kubectl get svc mealie -o yaml > service.yaml

# Edit the YAML file
nano service.yaml

# Apply the service
kubectl apply -f service.yaml
```

**Example Service YAML:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - port: 8080
      targetPort: 8080
      protocol: TCP
```

---

## üîÑ Port Forwarding (Development/Debugging)

### Pod Port Forward
```bash
kubectl port-forward pod/<pod-name> 9000 -n <namespace>
```

### Service Port Forward
```bash
kubectl port-forward svc/<service-name> 9000 -n <namespace>
```

**Characteristics:**
- Only works while terminal session is running
- Good for development and debugging
- **Not suitable for production** - temporary access only
- Handles connection through your local terminal

---

## üåç Ingress - HTTP/HTTPS Routing

### What is Ingress?
**Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.**

### Key Features
- **SSL/TLS termination** - Handle certificates at ingress level
- **External URLs/FQDNs** - Use custom domain names
- **Path-based routing** - Route based on URL paths
- **Host-based routing** - Route based on hostnames
- **Load balancing** - Distribute traffic across services

### Ingress Components
1. **Ingress Resource** - YAML configuration defining routing rules
2. **Ingress Controller** - Implements the actual routing logic

### Common Ingress Controllers
- **NGINX** - Most popular, feature-rich
- **Traefik** - Docker/Kubernetes native, automatic service discovery
- **Cilium** - eBPF-based, advanced networking
- **Cloud-specific**: 
  - **AGIC** (Azure Application Gateway Ingress Controller)
  - **AWS ALB Controller**
  - **GCP Ingress**

### Rancher Desktop Default
```bash
kubectl get svc -n kube-system
```
**Output:**
```
traefik    LoadBalancer   10.43.214.252   192.168.64.2   80:30213/TCP,443:31950/TCP
```

### Ingress Routing Flow
```
Internet ‚Üí Ingress Controller ‚Üí Ingress Rules ‚Üí Service ‚Üí Pods
```

### Example Ingress Resource
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mealie-ingress
spec:
  rules:
  - host: mealie.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: mealie
            port:
              number: 9000
```

---

## üìã Quick Commands Reference

```bash
# Services
kubectl get service                    # List services
kubectl get svc -o wide               # Detailed service info
kubectl expose deployment <name>      # Quick expose
kubectl edit svc <name>              # Edit service

# Networking Debug
kubectl get pods -o wide             # Show pod IPs and nodes
kubectl describe svc <name>          # Service details
kubectl get endpoints               # Service endpoints

# Port Forward
kubectl port-forward svc/<name> <local-port>:<service-port>
kubectl port-forward pod/<name> <local-port>:<pod-port>

# Ingress
kubectl get ingress                 # List ingress resources
kubectl describe ingress <name>     # Ingress details
```

---

## üéØ Best Practices

### Service Design
- Use **ClusterIP** for internal services
- Use **LoadBalancer** for external access in cloud environments
- Prefer **Ingress** over NodePort for HTTP/HTTPS traffic
- Always use **YAML files** for production deployments

### Naming and Organization
- Use descriptive service names
- Group related services with labels
- Use namespaces for logical separation
- Document service dependencies

### Security
- Avoid NodePort in production
- Use Network Policies to restrict pod-to-pod communication  
- Implement proper RBAC for service access
- Use TLS/SSL termination at Ingress level

### Monitoring
- Monitor service endpoints health
- Track service discovery metrics
- Monitor ingress controller performance
- Set up alerts for service unavailability