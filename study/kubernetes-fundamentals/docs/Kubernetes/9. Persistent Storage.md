# Kubernetes Persistent Storage (PV & PVC)

## üíæ Persistent Storage Fundamentals

### What are Persistent Volumes (PV) and Persistent Volume Claims (PVC)?

**Persistent Volume (PV)** - A cluster-wide storage resource that exists independently of pods
**Persistent Volume Claim (PVC)** - A request for storage by a user/application, like a "claim ticket" for part of a PV

### Key Concepts
- **PVCs are namespaced** - Live within specific namespaces
- **PVs are cluster-wide** - Available across all namespaces
- **Data persistence** - Survives pod deletions, restarts, and rescheduling
- **Decoupled lifecycle** - Storage lifecycle independent from pod lifecycle

---

## üéØ How PV & PVC Work Together

### The Storage Workflow
```
1. Storage Admin creates PV (or dynamic provisioning)
2. Developer creates PVC requesting storage
3. Kubernetes binds PVC to suitable PV
4. Pod mounts PVC as volume
5. Application uses persistent storage
```

### Binding Process
- **Static Provisioning** - Admin pre-creates PVs, PVCs bind to existing PVs
- **Dynamic Provisioning** - PVs are created automatically when PVC is created (using StorageClass)

---

## üìù YAML Examples

### Pre-Provisioned Persistent Volume
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mealie-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-path
  hostPath:
    path: /mnt/data/mealie-storage
```

### Persistent Volume Claim
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mealie-data
  namespace: mealie
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
  storageClassName: local-path
```

### Pod Using PVC
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mealie-app
  namespace: mealie
spec:
  containers:
  - name: mealie
    image: mealie:latest
    volumeMounts:
    - mountPath: /app/data
      name: mealie-storage
  volumes:
  - name: mealie-storage
    persistentVolumeClaim:
      claimName: mealie-data
```

### Deployment with PVC
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mealie-deployment
  namespace: mealie
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mealie
  template:
    metadata:
      labels:
        app: mealie
    spec:
      containers:
      - name: mealie
        image: mealie:latest
        volumeMounts:
        - mountPath: /app/data
          name: mealie-storage
      volumes:
      - name: mealie-storage
        persistentVolumeClaim:
          claimName: mealie-data
```

---

## üîê Access Modes Explained

### Available Access Modes

#### ReadWriteOnce (RWO)
- **Mount**: Single node, read-write access  
- **Use case**: Databases, single-instance applications
- **Support**: Most storage types
- **Example**: MySQL database storage

#### ReadOnlyMany (ROX)  
- **Mount**: Multiple nodes, read-only access
- **Use case**: Shared configuration, static content
- **Support**: NFS, some cloud storage
- **Example**: Shared configuration files

#### ReadWriteMany (RWX)
- **Mount**: Multiple nodes, read-write access
- **Use case**: Shared file systems, multi-writer scenarios  
- **Support**: NFS, some specialized storage
- **Example**: Shared application logs, content management

#### ReadWriteOncePod (RWOP)
- **Mount**: Single pod, read-write access (Kubernetes 1.22+)
- **Use case**: Strict single-pod access control
- **Support**: CSI drivers that support it
- **Example**: Single-instance databases with strict access control

### Access Mode Compatibility Matrix
| Storage Type | RWO | ROX | RWX | RWOP |
|--------------|-----|-----|-----|------|
| Local/HostPath | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ |
| NFS | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Azure Disk | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ |
| Azure Files | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| AWS EBS | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ |
| AWS EFS | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |

---

## üè™ Storage Classes

### What is a StorageClass?
A **StorageClass** defines how storage is dynamically provisioned and what type of storage to create.

### Check Available Storage Classes
```bash
kubectl get storageclasses.storage.k8s.io
# OR
kubectl get sc
```

**Example Output (Rancher Desktop):**
```
NAME                   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
local-path (default)   rancher.io/local-path   Delete          WaitForFirstConsumer   false                  18d
```

### StorageClass Components
- **Provisioner** - What creates the storage (e.g., rancher.io/local-path)
- **ReclaimPolicy** - What happens when PVC is deleted (Delete/Retain)
- **VolumeBindingMode** - When to bind PV to PVC
- **Parameters** - Storage-specific configuration

### Example StorageClass YAML
```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: kubernetes.io/azure-disk
parameters:
  storageaccounttype: Premium_LRS
  kind: Managed
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer
```

### Volume Binding Modes
- **Immediate** - Bind PV immediately when PVC is created
- **WaitForFirstConsumer** - Bind PV only when pod using PVC is created (better for topology constraints)

---

## üîÑ PVC Lifecycle States

### PVC Status Examples
```bash
kubectl get persistentvolumeclaims
```

**Status Options:**
```
NAME          STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS
mealie-data   Pending   -        -          -              local-path
mealie-data   Bound     pvc-123  500Mi      RWO            local-path
```

### Status Meanings
- **Pending** - Waiting for suitable PV or dynamic provisioning
- **Bound** - Successfully bound to a PV
- **Lost** - PV exists but is not available

---

## üåç Real-World Storage Scenarios

### On-Premises Kubernetes
```yaml
# NFS StorageClass
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs-storage
provisioner: nfs.csi.k8s.io
parameters:
  server: nfs-server.company.com
  share: /exports/k8s-storage
```

### Cloud Providers

#### Azure AKS
```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: azure-disk-premium
provisioner: kubernetes.io/azure-disk
parameters:
  storageaccounttype: Premium_LRS
  kind: Managed
reclaimPolicy: Delete
allowVolumeExpansion: true
```

#### AWS EKS
```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: aws-ebs-gp3
provisioner: ebs.csi.aws.com
parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
reclaimPolicy: Delete
allowVolumeExpansion: true
```

#### Google GKE
```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gce-ssd
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
reclaimPolicy: Delete
allowVolumeExpansion: true
```

---

## üí° Common Use Cases

### 1. Database Storage
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-storage
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: fast-ssd
```

### 2. Shared Configuration
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: shared-config
spec:
  accessModes:
  - ReadOnlyMany
  resources:
    requests:
      storage: 1Gi
  storageClassName: nfs-storage
```

### 3. Multi-Writer Logs
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: shared-logs
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: nfs-storage
```

### 4. StatefulSet Storage
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: nginx
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
      storageClassName: fast-ssd
```

---

## üõ°Ô∏è Data Persistence & Reclaim Policies

### Reclaim Policies
- **Retain** - Keep data when PVC is deleted (manual cleanup required)
- **Delete** - Automatically delete PV and underlying storage when PVC is deleted
- **Recycle** - Deprecated - basic scrub and make available again

### Testing Data Persistence
```bash
# Create deployment with PVC
kubectl apply -f deployment-with-pvc.yaml

# Write data to persistent storage
kubectl exec -it <pod-name> -- touch /app/data/important-file.txt

# Delete the deployment
kubectl delete deployment <deployment-name>

# Recreate the deployment
kubectl apply -f deployment-with-pvc.yaml

# Check if data persists
kubectl exec -it <new-pod-name> -- ls /app/data/
# important-file.txt should still be there!
```

---

## üìä Monitoring and Troubleshooting

### Essential Commands
```bash
# Check PVCs
kubectl get pvc -A
kubectl describe pvc <pvc-name> -n <namespace>

# Check PVs  
kubectl get pv
kubectl describe pv <pv-name>

# Check StorageClasses
kubectl get sc
kubectl describe sc <storage-class-name>

# Debug storage issues
kubectl get events -n <namespace>
kubectl logs <pod-name> -n <namespace>
```

### Common Issues & Solutions

#### PVC Stuck in Pending
```bash
# Check if StorageClass exists
kubectl get sc

# Check PV availability
kubectl get pv

# Check events for errors
kubectl describe pvc <pvc-name>
```

#### Pod Can't Mount Volume
```bash
# Check PVC is bound
kubectl get pvc

# Check pod events
kubectl describe pod <pod-name>

# Verify access modes match
kubectl describe pv <pv-name>
```

---

## üéØ Best Practices

### Storage Design
- **Right-size storage** - Don't over-provision, but allow for growth
- **Choose appropriate access modes** - Match your application needs
- **Use StorageClasses** - Prefer dynamic provisioning over static
- **Plan for backup** - Implement regular backup strategies

### Performance
- **Match storage type to workload** - SSD for databases, HDD for logs
- **Consider IOPS requirements** - Provision adequate performance
- **Use local storage carefully** - Great performance but no HA
- **Monitor storage usage** - Set up alerts for capacity

### Security
- **Encryption at rest** - Use encrypted storage classes
- **Access controls** - Implement proper RBAC for PVC management
- **Network policies** - Secure storage network traffic
- **Backup encryption** - Encrypt backups and snapshots

### High Availability
- **Replication** - Use replicated storage for critical data
- **Multi-zone** - Distribute storage across availability zones
- **Backup strategy** - Regular backups to different locations
- **Disaster recovery** - Test restore procedures regularly

---

## üìã Quick Commands Reference

```bash
# PVC Management
kubectl get pvc -A                           # List all PVCs
kubectl describe pvc <name> -n <namespace>   # PVC details
kubectl delete pvc <name> -n <namespace>     # Delete PVC

# PV Management  
kubectl get pv                               # List all PVs
kubectl describe pv <name>                   # PV details
kubectl patch pv <name> -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'

# StorageClass Management
kubectl get sc                               # List StorageClasses
kubectl describe sc <name>                   # StorageClass details
kubectl get sc -o yaml                       # All StorageClass configs

# Troubleshooting
kubectl get events --sort-by=.metadata.creationTimestamp
kubectl top nodes                            # Node storage usage
kubectl describe node <node-name>           # Node storage details
```

